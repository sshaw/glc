package glc

import (
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"os/user"
	"path"
	"strconv"
	"strings"
	"golang.org/x/net/html"
	"golang.org/x/oauth2"

	"github.com/mvdan/xurls"
	"github.com/google/go-github/github"
)

const (
	Issue = "IssueEvent"
	IssueComment = "IssueCommentEvent"
	PullRequest = "PullRequestEvent"
	PullRequestComment = "PullRequestCommentEvent"

	dbName = "db"
	glcDir = ".glc"

	version = "v0.0.1"
	userAgent = "GLC " + version
)

const eventMaxPages = 10

var eventTypes = []string{ Issue, IssueComment, PullRequest /*, PullRequestComment */ }

// Criteria used to determine the events to look for
type EventOptions struct {
	// GitHub events to process.
	// Currently supports only IssueEvent, IssueCommentEvent, and PullRequestEvent
	Events []string

	//IgnoreFiles []string

	// Ignore events generated by the given users
	ExcludeUsers []string

	// Only process events generated by the given users
	IncludeUsers []string

	// Ignore events on the given repositories. Repositories must be in user/repo format.
	ExcludeRepos []string

	// Only process events on the given repositories. Repositories must be in user/repo format.
	IncludeRepos []string
}


// Optional parameters for the GitHub Link Checker
type GLCOptions struct {
	// Path to event DB, defaults to $HOME/.glc
	DB string

	// GitHub API token
	AccessToken string

	// Turn on debug mode
	Debug bool
}

// The GitHub Link Checker
type GLC struct {
	gh *github.Client
	db string
	lastEventProcessed string
	includeEvents []string
	includeUsers map[string]bool
	excludeUsers map[string]bool
	includeRepos map[string]bool
	excludeRepos map[string]bool
}

// Create a new GitHub Link Checker. Token is an optional GitHub API token.
func New(options *GLCOptions) *GLC {
	var gh *github.Client
	var client *http.Client
	var db string

	if options == nil {
		options = &GLCOptions{}
	}

	if options.AccessToken != "" {
		ts := oauth2.StaticTokenSource(&oauth2.Token{AccessToken: options.AccessToken})
		client = oauth2.NewClient(oauth2.NoContext, ts)
	}

	db = options.DB
	if db == "" {
		user, err := user.Current()
		if err != nil {
			panic(fmt.Sprintf("Failed to lookup current user, cannot create DB: %s", err))
		}

		db = user.HomeDir
	}

	db = path.Join(db, glcDir)
	gh = github.NewClient(client)
	gh.UserAgent = fmt.Sprintf("%s (%s)", userAgent, gh.UserAgent)

	return &GLC{gh: gh, db: db}
}

// Find GitHub activity containing fragile URLs in the given repositories.
func (glc *GLC) FindRepositoryEvents(user, repo string, eventOptions *EventOptions) ([]*Event, error) {
	var events []*Event

	glc.initOptions(eventOptions)

	listOptions := github.ListOptions{Page: 1}
	for listOptions.Page > 0 {
		ghEvents, resp, err := glc.gh.Activity.ListRepositoryEvents(user, repo, &listOptions)
		if err != nil {
			return nil, fmt.Errorf("Error finding repository events: %s", err)
		}

		glcEvents, err := glc.processEvents(ghEvents)
		if err != nil {
			return nil, fmt.Errorf("Error processing repository events: %s", err)
		}

		listOptions.Page = resp.NextPage
		events = append(events, glcEvents...)
	}

	return events, nil
}

// Find GitHub activity containing fragile URLs. By default this looks
// at GitHub's list of public events.
func (glc *GLC) FindEvents(eventOptions *EventOptions) ([]*Event, error) {
	var events []*Event

	glc.initOptions(eventOptions)
	glc.lastEventProcessed = readLastEventId(glc.db)

	listOptions := github.ListOptions{}

	// GitHub's event feed does not have a Link header with page info
	for page := eventMaxPages; page >= 1; page-- {
		listOptions.Page = page

		ghEvents, _, err := glc.gh.Activity.ListEvents(&listOptions)
		// TODO: glc.gh.CheckResponse()
		if err != nil && err != io.EOF {
			return nil, fmt.Errorf("Error retrieving events: %s", err)
		}

		if len(ghEvents) == 0 || glc.eventHasBeenProcessed(*ghEvents[0].ID) {
			break
		}

		glcEvents, err := glc.processEvents(ghEvents)
		if err != nil {
			return nil, fmt.Errorf("Error processing events: %s", err)
		}

		glc.lastEventProcessed = *ghEvents[0].ID

		events = append(events, glcEvents...)
	}

	// TODO: defer? How does it behave with signals?
	writeLastEventId(glc.db, glc.lastEventProcessed)

	return events, nil
}

func (glc *GLC) initOptions(options *EventOptions) {
	glc.includeEvents = eventTypes

	if options == nil {
		return
	}

	if len(options.Events) > 0 {
		glc.includeEvents = options.Events
	}

	glc.includeUsers = arrayToMap(options.IncludeUsers)
	glc.excludeUsers = arrayToMap(options.ExcludeUsers)
	glc.includeRepos = arrayToMap(options.IncludeRepos)
	glc.excludeRepos = arrayToMap(options.ExcludeRepos)
}

func (glc *GLC) processEvents(ghEvents []github.Event) ([]*Event, error) {
	var events []*Event

	for _, ghEvent := range(ghEvents) {

		glcEvent := glc.loadEvent(&ghEvent)
		if glc.ignoreEvent(glcEvent) {
			continue
		}

		corrections, err := glc.findCorrections(glcEvent.Body)
		if err != nil {
			return nil, err
		}

		// If there's nothing to correct then we don't care about the event
		if len(corrections) > 0 {
			glcEvent.Corrections = corrections
			events = append(events, glcEvent)
		}
	}

	return events, nil
}

// Should check DefaultBranch and not master
//
// TODO: error handling
func (glc *GLC) urlHasGitTag(url *GitHubURL) bool {
	tags, _, err := glc.gh.Repositories.ListTags(url.User, url.Repo, nil)
	if err != nil {
		panic(err)
	}

	for _, tag := range(tags) {
		if *tag.Name == url.ID {
			return true
		}
	}

	return false
}

func (glc *GLC) correctURL(badURL *GitHubURL) (*GitHubURL, error) {
	options := github.CommitsListOptions{
		SHA: badURL.ID,
		ListOptions: github.ListOptions{PerPage: 1},
	}

	commits, _, err := glc.gh.Repositories.ListCommits(badURL.User, badURL.Repo, &options)
	if err != nil {
		return nil, err
	}

	// TODO: can len(commits) == 0?
	rawurl := strings.Replace(badURL.String(), badURL.ID, *commits[0].SHA, 1)
	newURL, err := parseGitHubURL(rawurl)
	if err != nil {
		return nil, err
	}

	if newURL == nil {
		return nil, fmt.Errorf("Failed to parse corrected GitHub URL: %s", rawurl)
	}

	return newURL, nil
}

func (glc *GLC) findURLsToFix(body string) (map[string][]*GitHubURL, error) {
	urlsToFix := make(map[string][]*GitHubURL)

	for _, url := range(xurls.Strict.FindAllString(body, -1)) {
		oldURL, err := parseGitHubURL(url)
		if err != nil {
			return nil, err
		}

		// nil means that it wasn't a GitHub URL
		if oldURL != nil && !oldURL.IsPermanent() && !glc.urlHasGitTag(oldURL) {
			newURL, err := glc.correctURL(oldURL)
			if err != nil {
				return nil, err
			}

			urlsToFix[url] = []*GitHubURL{ oldURL, newURL }
		}
	}

	return urlsToFix, nil
}

func (glc *GLC) findCorrections(body string) ([]*Correction, error) {
	urlsToFix, err := glc.findURLsToFix(body)
	if err != nil {
		return nil, err
	}

	corrections := []*Correction{}

	if len(urlsToFix) > 0 {
		// If we have links we parse the Markdown into an HTML doc so that we can extract a snippet
		// that will provide context for each correction
		doc, _, err := glc.gh.Markdown(body, nil)
		if err != nil {
			return nil, err
		}

		err = findLinks(func (node *html.Node) {
			for _, attr := range(node.Attr) {
				if attr.Key == "href" {
					urls, ok := urlsToFix[attr.Val]
					if ok {
						correction := &Correction{
							OldURL: *urls[0],
							NewURL: *urls[1],
							Context: excerptHTML(node, 25),
						}

						corrections = append(corrections, correction)
					}

					break
				}
			}
		}, doc)

		if err != nil {
			return nil, err
		}
	}


	return corrections, nil
}

func (glc *GLC) ignoreUser(user string) bool {
	user = strings.ToLower(user)
	if len(glc.includeUsers) > 0 {
		return !glc.includeUsers[user]
	}

	return glc.excludeUsers[user]
}

func (glc *GLC) ignoreRepo(event *Event) bool {
	repo := strings.ToLower(event.Repo)
	if len(glc.includeRepos) > 0 {
		return !glc.includeRepos[repo]
	}

	return glc.excludeRepos[repo]
}

func (glc *GLC) eventHasBeenProcessed(id string) bool {
	return id <= glc.lastEventProcessed
}

func (glc *GLC) ignoreType(eventType string) bool {
	for _, t := range(glc.includeEvents) {
		if eventType == t {
			return false

		}
	}

	return true
}

func (glc *GLC) ignoreEvent(event *Event) bool {
	if event == nil || glc.eventHasBeenProcessed(event.eventID) || glc.ignoreType(event.Type) || glc.ignoreUser(event.Actor) || glc.ignoreRepo(event) {
		return true
	}

	return false
}

func (glc *GLC) loadEvent(ghEvent *github.Event) *Event {
	var body *string
	var id, number int
	var event *Event

	// TODO: This should just be added to go-github
	// https://github.com/google/go-github/blob/0a0089e75908125e861b84d1390412b4166d4d55/github/activity_events.go#L32
	switch *ghEvent.Type {
	case IssueComment:
		// Comment on an issue or a pull request
		issue := github.IssueCommentEvent{}
		loadJSON(ghEvent, &issue)
		id = *issue.Comment.ID
		number = *issue.Issue.Number
		body = issue.Comment.Body
	case Issue:
		// Issue created
		issue := github.IssueEvent{}
		loadJSON(ghEvent, &issue)
		if *issue.Event == "opened" {
			id = *issue.ID
			number = *issue.Issue.Number
			body = issue.Issue.Body
		}
	case PullRequest:
		// Pull request created
		pr := github.PullRequestEvent{}
		loadJSON(ghEvent, &pr)
		if *pr.Action == "opened" {
			// This isn't exposed by go-github
			//id = *pr.PullRequest.ID
			number = *pr.Number
			body = pr.PullRequest.Body
		}
		//case PullRequestReviewCommentEvent:
		// Comment on the code in a pull request
		// To comment on source code (review comment) need repo, PR #, commit_id, path, position
		// PullRequestService.CreateComment
		// https://godoc.org/github.com/google/go-github/github#PullRequestsService.CreateComment
	}

	if body != nil {
		// ghEvent.Repo.Owner is only set on webhooks
		repo := strings.Split(*ghEvent.Repo.Name, "/")
		event = &Event{
			gh: glc.gh,
			eventID: *ghEvent.ID,
			repoName: repo[1],
			repoOwner: repo[0],

			ID: id,
			Number: number,
			Repo: *ghEvent.Repo.Name,
			Body: *body,
			Type: *ghEvent.Type,
			CreatedAt: *ghEvent.CreatedAt,
			Actor: *ghEvent.Actor.Login,
		}
	}

	return event
}

func writeLastEventId(root string, id string) {
	errMessage := "Failed to write to DB %s: %s"
	path := path.Join(root, dbName)

	err := os.MkdirAll(root, 0700)
	if err != nil {
		panic(fmt.Sprintf(errMessage, path, err))
	}

	err = ioutil.WriteFile(path, []byte(id), 0600)
	if err != nil {
		panic(fmt.Sprintf(errMessage, path, err))
	}
}

func readLastEventId(root string) string {
	eventID := "0"
	errMessage := "Failed to read from DB %s: %s"
	path := path.Join(root, dbName)

	_, err := os.Stat(path)
	if err != nil {
		if !os.IsNotExist(err) {
			panic(fmt.Sprintf(errMessage, path, err))
		}
	} else {
		data, err := ioutil.ReadFile(path)
		if err != nil {
			panic(fmt.Sprintf(errMessage, path, err))
		}

		if len(data) > 0 {
			id := strings.TrimRight(string(data), "\n\r")
			_, err := strconv.ParseUint(id, 10, 64)
			if err == nil {
				eventID = id
			}
		}
	}

	return eventID
}

func arrayToMap(array []string) map[string]bool {
	set := make(map[string]bool)
	for _, s := range(array) {
		set[ strings.ToLower(s) ] = true
	}

	return set
}

func loadJSON(event *github.Event, payload interface{})  {
	if err := json.Unmarshal(*event.RawPayload, &payload); err != nil {
		panic(err.Error())
	}
}
